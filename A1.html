<!DOCTYPE html>
<!-- saved from url=(0080)https://www.cse.iitd.ac.in/~rijurekha/col380_2024/openmp_pthread_assignment.html -->
<html data-darkreader-mode="dynamic" data-darkreader-scheme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, ::-webkit-calendar-picker-indicator, img.Wirisformula {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #181a1b !important;
}
html {
    color-scheme: dark !important;
}
html, body {
    background-color: #181a1b;
}
html, body {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #404400 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}</style>
        
        <title>Teaching</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.2">
        <link href="./A1_files/bootstrap.min.css" rel="stylesheet"><style class="darkreader darkreader--sync" media="screen"></style>
        <link href="./A1_files/group.css" rel="stylesheet"><style class="darkreader darkreader--sync" media="screen"></style>
        <link href="https://www.cse.iitd.ac.in/~rijurekha/col380_2024/style.css" rel="stylesheet&quot;">
	<link rel="shortcut icon" href="https://www.cse.iitd.ac.in/~rijurekha/col380_2024/riju.JPG">
  
<style>
table {
    font-family: arial, sans-serif;
    border-collapse: collapse;
    width: 100%;
}

td, th {
    border: 1px solid #dddddd;
    text-align: left;
    padding: 8px;
}

tr:nth-child(even) {
    background-color: #dddddd;
}
</style><style class="darkreader darkreader--sync" media="screen"></style>


<meta name="darkreader" content="7bbeead542cb403ab98022619cd4328f"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
#vimvixen-console-frame {
    color-scheme: light !important
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: #032029 !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: #0a0a0a !important;
}
.tou-uknfeu {
    background-color: #231603 !important;
}
.tou-6i3zyv {
    background-color: #19576c !important;
}
div.mermaid-viewer-control-panel .btn {
  fill: var(--darkreader-neutral-text);
  background-color: var(--darkreader-neutral-background);
}
svg g rect.er {
  fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
  fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
  fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
  fill-opacity: 0.8 !important;
  fill: var(--darkreader-selection-background);
}
svg rect.er.relationshipLabelBox {
  fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect, svg g g.nodes polygon {
  fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
  fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0, svg line.messageLine1 {
  stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
  fill: var(--darkreader-neutral-background) !important;
}
.google-material-icons {
    font-family: 'Google Material Icons' !important;
}
.google-symbols {
    font-family: 'Google Symbols' !important;
}
.material-icons-extended {
    font-family: 'Material Icons Extended' !important;
}
mitid-authenticators-code-app > .code-app-container {
    padding-top: 1rem;
    background-color: white !important;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
.ms-Icon {
    font-family: 'FabricMDL2Icons' !important;
}</style></head>

<body><a name="assignment1"><h2>Assignment 1: Due on Feb 15, 2024</h2></a>
In this assignment, you will develop two parallel implementations of
LU decomposition that use Gaussian elimination 
to factor a dense <em>N</em> x <em>N</em> matrix into an upper-triangular one and a lower-triangular
one. 
In matrix computations, <em>pivoting</em> involves finding the largest magnitude value in a row,
column, or both and then interchanging rows and/or columns in the
matrix for the next step in the algorithm. 
The purpose of pivoting is to reduce round-off error, which enhances numerical stability.
In your assignment, you will use row pivoting, a form of
pivoting involves interchanging rows of a trailing submatrix based on
the largest value in the current column.
To perform LU decomposition with row pivoting, you will compute a permutation matrix
<b>P</b> such that <b>P</b><b>A</b> = <b>L</b><b>U</b>. 
The permutation matrix keeps track of row exchanges performed.

<br>
<br>
Below is pseudocode for a sequential implementation of LU
decomposition with row pivoting.<br>

<pre>    inputs: a(n,n)
    outputs: π(n), l(n,n), and u(n,n)

    initialize π as a vector of length n
    initialize u as an n x n matrix with 0s below the diagonal
    initialize l as an n x n matrix with 1s on the diagonal and 0s above the diagonal
    for i = 1 to n
      π[i] = i
    for k = 1 to n
      max = 0
      for i = k to n
        if max &lt; |a(i,k)|
          max = |a(i,k)|
          k' = i
      if max == 0
        error (singular matrix)
      swap π[k] and π[k']
      swap a(k,:) and a(k',:)
      swap l(k,1:k-1) and l(k',1:k-1)
      u(k,k) = a(k,k)
      for i = k+1 to n
        l(i,k) = a(i,k)/u(k,k)
        u(k,i) = a(k,i)
      for i = k+1 to n
        for j = k+1 to n
          a(i,j) = a(i,j) - l(i,k)*u(k,j)
          
    Here, the vector π is a compact representation of a permutation matrix p(n,n), 
    which is very sparse. For the <em>i</em>th row of p, π(i) stores the column index of
    the sole position that contains a 1.
</pre>
You will write two shared-memory parallel programs that perform LU
decomposition using row pivoting. You will develop one solution using the Pthreads programming model and one using OpenMP.

<br>
<br>
Each LU decomposition implementation should accept two arguments:
<em>n</em> - the size of a matrix, followed by <tt>t</tt> - the number
      of threads.  
Your programs will allocate an <em>n</em> x <em>n</em> 
matrix <b><tt>a</tt></b> of double precision
      (64-bit) floating point variables. You should initialize the
    matrix with uniform random numbers computed using a suitable random number generator, such as <a href="http://linux.die.net/man/3/drand48"><tt>drand48</tt></a>, <a href="http://linux.die.net/man/3/drand48_r"><tt>drand48_r</tt></a>, or the <a href="http://en.cppreference.com/w/cpp/numeric/random">C++11 facilities for pseudo-random
    number generation</a>. (Note: if you are generating random numbers in parallel, you
      will need to use a reentrant random number generator and seed the
      random number generator for each thread differently.) 
Apply LU decomposition with partial pivoting to
factor the matrix into an upper-triangular one and a lower-triangular one.

<br>
<br>

To check your answer, compute the sum of Euclidean norms of the columns of the residual matrix (this sum is known
      as the <a href="https://en.wikipedia.org/wiki/Matrix_norm#L2.2C1_norm">L2,1 norm</a>)
computed as <b>P</b><b>A</b>-<b>L</b><b>U</b>. Print the value of the L2,1 norm of the
      residual. (It should be <i>very</i> small.)
<p>
The verification step need not be
      parallelized. Have your program time
      the LU decomposition phase by reading the
      real-time clock before and after and printing the
      difference. 
</p><p>
The formal components of the assignment are listed below:
</p><ul>
<li> Write a shared-memory parallel program that uses OpenMP
to perform LU decomposition with partial pivoting.
</li>
<br> 
<li> Write a shared-memory parallel program that uses Pthreads 
to perform LU decomposition with partial pivoting.
</li>
<br>
<li> Write a document that describes how
your programs work. This document should <em>not</em> include your
programs, though it may include figures containing pseudo-code that
sketch the key elements of your parallelization strategy for each
implementation. Explain how
your program partitions the data, work and exploits parallelism. 
Justify your implementation choices.
Explain how the parallel work is synchronized.  
<p>
Use problem size <i>n = 8000</i> to evaluate the performance of your
implementations. If your sequential running
      time is too long for the interactive queue, you 
may base your timing measurements on n=7000.

Prepare a table that includes your timing
measurements for the LU decomposition phase of your
implementations on 1, 2, 4, 8, and 16 threads. 
Plot graphs of the parallel
efficiency of your program executions. 
Plot a point for each of the executions. 
The x axis should show the number of processors. The Y
axis should show your measured parallel efficiency for the execution.
Construct your plot so that the X axis of the graph intersects the Y
axis at Y=0.
</p></li> </ul> 
<p>

In this assignment, reading and
writing shared data will account for much of the execution cost.
Accordingly, you should pay attention to how you lay out the data and
how your parallelizations interact with your data layout.
You should consider whether you want to use a contiguous layout for
the array, or whether you want to represent the array as a vector,
of <b>n</b> pointers to n-element data vectors.
You should explicitly consider how false sharing might arise and take
appropriate steps to minimize its impact on performance.

<!---
Slides:<a href="https://docs.google.com/presentation/d/18DgFHvg4bQ5hf_ZTyeUFzSKx1Riln6BpIEtNPbUwYGQ/edit?usp=sharinghttps://docs.google.com/presentation/d/18DgFHvg4bQ5hf_ZTyeUFzSKx1Riln6BpIEtNPbUwYGQ/edit?usp=sharing"><b> Lecture1</b></a>, <a href="https://docs.google.com/presentation/d/1F3iiuU6EFcwzTOUXWAa0bxIrsS1BGjViqAFO_eeUEvE/edit?usp=sharing"><b> Lecture2</b></a>, <a href="https://drive.google.com/file/d/1eIkRt21JQHW5qbQ2-2xhSV0IayaEKwcs/view?usp=sharing"><b> Lecture3i</b></a>, <a href="https://drive.google.com/file/d/12EKYHViG7wx3fXs7_kCDMMHlhj15-UcY/view?usp=sharing"><b> Lecture4</b></a> 
-->

</p></body></html>